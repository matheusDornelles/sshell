Matheus Dornelles Barbosa Maia
mbarbosa25@ubishops.ca
2362581

================================================================================
                            RSSHELL - Assignment 2
                         Remote Shell TCP/IP Client
================================================================================

WHAT IS THIS?

rsshell is a Unix shell that talks to remote servers over the network. It's
like your regular shell, but you can send commands to remote servers (SMTP,
HTTP, or any TCP service) and see their responses.

Built on the Assignment 1 framework by Dr. Stefan D. Bruda, with full
networking added for Assignment 2.

================================================================================
HOW IT WORKS
================================================================================

CONNECTIONS:
- Opens TCP connections to whatever server you configure
- Talks to the server and shows you what it says back
- Can keep connections open (keepalive mode) or close after each command
- Won't hang if the server takes too long to respond

BACKGROUND COMMANDS:
- Put '&' before a command to run it in the background
- Your prompt comes back immediately while the response loads
- Multiple background commands can run at once
- Their responses might get mixed together - that's normal!

COMPATIBILITY:
- Works with servers using \n or \r\n line endings
- Detects when servers close the connection
- Doesn't freeze on slow or unresponsive servers

SETTINGS (in shconfig file):
  RHOST - which server to connect to
  RPORT - which port to use  
  VSIZE - terminal height
  HSIZE - terminal width

================================================================================
HOW TO BUILD
================================================================================

You'll need a Unix/Linux system with g++ and make installed.

  $ make clean && make

That's it! You'll get an 'rsshell' executable.

================================================================================
TESTING
================================================================================

QUICK AUTOMATED TEST:

  $ ./test.sh

This runs through all 10 assignment requirements automatically. Note that
server responses might not show up in automated tests because of how
stdin works with pipes - that's fine, the commands are still being sent.

INTERACTIVE TESTING (recommended for seeing actual responses):

  $ ./rsshell
  sshell> ! keepalive
  sshell> HELO test.com
  (wait to see server response)
  sshell> MAIL FROM:<test@test.com>
  (wait for response)
  sshell> ! close
  sshell> ! exit

================================================================================
HOW TO USE IT
================================================================================

Start it up:
  $ ./rsshell

LOCAL COMMANDS (start with !)
  ! ls                 Run commands on your computer
  ! more file.txt      View files with paging
  ! keepalive          Keep the connection open
  ! close              Close the connection
  ! exit               Quit the shell
  ! & command          Run something in the background

REMOTE COMMANDS (no ! prefix)
  HELO example.com     Send to server, wait for response
  & QUIT               Send to server, don't wait (returns prompt immediately)

The '&' makes commands asynchronous - you get your prompt back right away
while the response comes in the background. Note: the '&' itself isn't sent
to the server, it's just for controlling how rsshell handles the command.

CONFIGURATION (edit shconfig)
  RHOST localhost      Which server to connect to
  RPORT 8001           Which port
  VSIZE 30             Your terminal height  
  HSIZE 80             Your terminal width

================================================================================
HOW CONNECTIONS WORK
================================================================================

NORMAL MODE (default):
  Opens a new connection for each command, closes it after getting the response.
  Good for occasional commands.

KEEPALIVE MODE (type "! keepalive"):
  Opens one connection and keeps it open for all your commands.
  Much faster if you're sending lots of commands.
  Closes when you type "! close" or when you exit.
  Also closes if the server hangs up on you.

WAITING vs NOT WAITING:

Without &:
  You type a command → shell waits → shows response → gives you the prompt
  
With &:
  You type a command → prompt comes back immediately → response shows up when ready
  
Multiple & commands can run at the same time, which means their responses
might get jumbled together. That's not a bug, it's just how concurrent
processes work!

================================================================================
WHY DO ASYNC RESPONSES GET JUMBLED?
================================================================================

Assignment question: "Do asynchronous command responses come back interleaved?
Why or why not?"

Short answer: YES, they absolutely can get interleaved!

Here's why:

WHEN YOU USE &:
Each & command creates a separate process (using fork()). So three & commands
= three separate processes all running at the same time.

THEY ALL WANT TO READ:
Each process tries to read the server's response. The operating system decides
which process gets to run when - it's not predictable. Whichever process
happens to run first grabs the next chunk of data.

IN KEEPALIVE MODE IT'S WORSE:
Without keepalive: Each command has its own connection, so less interference
With keepalive: All commands share ONE connection, so they're all fighting
                over the same data stream

THE OS DECIDES:
The kernel's scheduler picks which process runs when. It depends on system
load, timing, random chance. There's no coordination between the processes -
they just grab whatever data they can, whenever they get a chance to run.

EXAMPLE:

You type fast:
  & This is command one
  & This is command two
  & This is command three

You might see:
  This is command one
  This is command two  
  This is command three

Or you might see:
  This is command
  This is command one
  two
  This is command three

Or even:
  This is c
  ommand o
  This is
  ne
  command two
  This is command three

All of these are correct! There's no synchronization between the processes,
so they just grab data whenever they get scheduled to run.

IS THIS A BUG?

Nope! This is exactly how async commands should work. If you want responses
in order, don't use &. If you use &, you're saying "I don't want to wait,
just show me stuff as it comes in" - and that means you might get jumbled
output when multiple commands run at once.

To fix it, you'd need mutexes or message queues to coordinate between
processes. But then they wouldn't be asynchronous anymore!

TESTED AND WORKING:
All this was tested with the SMTP server at linux.ubishops.ca:25.
Everything works as expected - keepalive mode, async commands, proper
response handling, all 10 assignment requirements verified.

================================================================================
WHAT'S IN HERE
================================================================================

SOURCE FILES:
  sshell.cc         - Main program (Assignment 2 work goes here)
  tcp-utils.h/cc    - Network utilities (by Dr. Bruda)
  tokenize.h/cc     - String parsing (by Dr. Bruda)

BUILD:
  Makefile          - Compiles everything into 'rsshell'

CONFIG & TESTING:
  shconfig          - Server settings (RHOST, RPORT, etc.)
  testmore          - Sample file for testing
  test.sh           - Automated test script

DOCS:
  README            - You're reading it!

================================================================================
CREDITS
================================================================================

Base framework from Dr. Stefan D. Bruda (Assignment 1):
  - tcp-utils and tokenize libraries
  - Shell structure, signal handling
  - Configuration file parsing

Assignment 2 additions:
  - All the networking stuff (connecting to servers, sending commands)
  - Keepalive mode
  - Background command execution (&)
  - Making it all work together!

Tested against linux.ubishops.ca:25 (SMTP server) - everything works!

================================================================================
REQUIREMENTS CHECKLIST
================================================================================

All 10 assignment requirements implemented and tested:

✓ 1.  Local commands with '!' prefix
✓ 2.  Remote commands sent to configured server
✓ 3.  Responses displayed correctly
✓ 4.  Asynchronous execution with '&'
✓ 5.  Handles both \r\n and \n line endings
✓ 6.  Keepalive mode works
✓ 7.  Close command works
✓ 8.  Detects when server closes connection
✓ 9.  Makefile builds rsshell
✓ 10. Full documentation and testing

Compiles clean (no errors or warnings).
Tested with real SMTP server - all features work.

================================================================================
KNOWN QUIRKS
================================================================================

A few minor things (inherited from the Assignment 1 base):

- Really long lines in 'more' might get cut off
- Commands over 128 characters get truncated
- Paging files needs blank line + enter (not just enter)

Nothing that affects the networking functionality.

================================================================================


